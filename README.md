# 0. 이 내용을 올리게 된 계기

리팩토링이라는 책을 감명 깊게 읽고 https://github.com/WegraLee/Refactoring

마침 골머리를 앓고 있던 버그를 해결하기 위해 적용함



# 1. 처음 시작

ReutersMessenger는 일자별로 채팅 내역을 xml 형태로 제공함. 그렇지만 너무 가독성이 떨어져서, txt 파일로 채팅 내역만 
뽑아내는 프로그램을 사용하고 있었음.

원래는 한방에 모든 걸 뽑아내는 프로그램이어서, 중간중간에 file을 열고 write를 했음. 

그런데 실제로 운용하다보니, 전체 채팅을 원하는 사람은 없고 특정 유저의 채팅 내역 추출을 원함.
그래서 특정유저 이름 한명을 받고, 전체는 f1에, 특정은 f2에 write하도록 바꿈.


# 2. 복수 유저의 중복 for문과 write 제거

여기까지는 잘 작동했으나, 이제 복수의 날짜에 복수의 유저를 추출하도록 원하는 사람들이 나옴.

원래 복수의 날짜에서 뽑아내는 기능은 있었으나 복수의 유저는 감안하지 않았기에, 해당프로그램을 복수의 유저수만큼 
 작동해야 함. 

그래서 원래 있던 날짜별 for문 안에, user별 for문을 삽입해 이중 for문으로 돌게 함.

이렇게 하니까 file write가 복수 개가 동시에 열렸다 닫혔다 하다보니 file open을 동시에 세개 넘게 하는 순간부터 속도가 
급격히 느려짐. 

그래서 text_arr이란 변수를 두고 그 안에 write할 내용을 다 담아둔 다음, 날짜 몫의 xml 파일 분석이 다 끝나고 나서 
for문을 돌면서 한번에 write 하게 함. 

이러니까 병목이 없어짐.

원래는 user, dest_cnt, dest_chk, 이런 array를 정의 한 후 각각 따로 돌리고 있었는데, 너무 구려보여서 dict 형태로 
 바꾸려고 소스 이름에 Dict를 추가했는데, 
Dict를 추가하는 것이 속도에는 전혀 장점이 없어보여서 실행하지 않음.


# 3. 특정 유저의 많은 용량이 문제가 됨

 그러다가 특정 유저의 채팅 내역을 뽑으려 하면 먹통이 됨을 알게 됨. 
  xml의 50메가이면 이 유저의 채팅이 10메가를 넘어가게 되는데, 멈춘줄 알았으나 한시간이 걸린 후 
  결과 파일이 생성됨을 알게 됨. 

  이 문제를 고민하다가, event 루프가 잘못하다가 user for문 안에 들어가서, 대화가 중복으로 기록됨을 알게 됨 
  (user수만큼 곱해서) 이게 언제부터 있는 버그인지 모르겠지만 일단 indent 문제를 해결한 것이 second 적용점.

 그러다가 마침 리팩토링책을 읽기 시작해서, 적용을 하기 위해서 먼저 중복된 부분을 꺼내야 한다는 말을 듣게 됨.

 내가 생각하기에 문제점은, text_arr이라는 string 배열의 내용이 1mb 단위일때까지는 괜찮은데, 10mb 단위가 되면 
 급격히 느려지는 게 아닐까 의심했음. 

 그런데 text_arr += string 구문형태로 내용을 추가하다보니, 중간중간 마다 사이즈를 체크하는 구문을 넣을 수가 없음.

 그래서 원래 생각하던 dict가 아닌 class 형태가 필요함을 깨닫고 그렇게 분리를 시작함.

 원래 구현부분을 복사해서 꺼내면서 시작하라고 했지만, 시작부분은 그냥 쉽게 시작할 수 있었음. 

  class 초기화 함수에 user_name만 넣었다가, RefDate도 file write를 할 때 필요하단 걸 알고 추가함

 리팩토링 책에 따라 기존 함수부분을 건드리지 않고 추가로 User로 출력하는 부분을 더해서, 두개의 파일을 
 쌍으로 비교를 함. 그리고 잘 작동할 때 기존  text_arr 추가 부분을 지움.

  그후 문제가 된 유저를 대상으로 User.setText에서 길이를 체크하고 그때 바로 write하는 부분을 추가해봄.

  문제 해결! write할때마다 write 카운트를 넣었더니 대부분의 유저는 3번 이내만 write했는데 (사이즈 10k 기준) 

  특정유저의 특정 대화만 write 수가 189까지 올라감. 

   write하는 기준을 10k로 한 것은 임의 값이었는데, 이대로 속도가 빨리 나와서 그대로 두기로 함. 대부분의 유저가 
   3회 이하이기 때문에 늘리는 장점이 별로 없어보임. 그리고 at 형태로 write를 하고 닫으면 별 속도 저하가 없음. 
   
   2에서 발생한 문제는 날짜별 for문 초반에 복수의 파일을 open한 상태로 진행하여 무척 느려진 거였음

  # 4. Super User 추가

   이전 방식에서는 지저분해서 추가하기 힘들었던 전체 채팅 추출을 추가함. 이전 방식에서는 전체 파일을 
   날짜가 끝날때 write하다보니, 용량이 너무 많아 전체 채팅의 text_arr을 가지기 힘들었음. 그런데 바뀐 user에서 
   user_name 없는 SuperUser를 추가하고, setText(이 함수는 addText가 더 맞는 이름으로 보이는데) 
   를 통해서 중간중간 추가하는 부분을 바꾸고 write 하니 추가가 가능함.

   그렇데 이렇게 되면 파일 크기가 커서 좀 부담이 되어 보여서, bChk 변수로 사용 안 하는 상태로 바꿔둠. 
   필요하면 상태 바꿀 수 있도록. 원래 bChk는 addText를 할때 유효하지 않은 User면 그냥 return 하는 방식으로 
   쓰려고 했는데, 기존의 배열 처리 방식에서 dest_chk를 check하면 함수호출을 덜할 수 있으므로 그냥 남겨둠.

  SuperUser에선 유용하게 쓰임.
